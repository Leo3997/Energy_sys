



### 🛠️ 最佳修复方案：混合查询策略

我建议修改 `get_device_list` 接口，让它执行 **“远程 + 本地”** 双重搜索。无论远程库有没有数据，只要你的 Python 模拟器开着，列表里就会显示出来，保证演示不冷场。

请用以下代码完全替换 `backend_server_influx.py` 中的 `get_device_list` 函数：

```python
@app.route('/api/devices/list')
def get_device_list():
    """
    获取设备列表：
    1. 尝试从远程 MONITOR 库查询真实设备。
    2. 合并当前内存中已连接的模拟设备 (GLOBAL_STATE)。
    """
    devices = set() # 使用集合去重

    # --- 步骤 A: 查询远程 InfluxDB (MONITOR_URL) ---
    try:
        if MONITOR_TOKEN:
            # 注意：这里我们加上 try-except，防止远程连不上导致整个接口报错，
            # 从而导致连本地设备都显示不出来。
            try:
                client = InfluxDBClient(url=MONITOR_URL, token=MONITOR_TOKEN, org=MONITOR_ORG)
                query_api = client.query_api()
                
                # ⚠️ 注意：请确认远程库里的 Tag 名字真的是 "device" 吗？
                # 如果查不到，可能需要改成 "device_id" 或 "code"
                query = f'import "influxdata/influxdb/schema"\n schema.tagValues(bucket: "{MONITOR_BUCKET}", tag: "device")'
                
                tables = query_api.query(query)
                for table in tables:
                    for record in table.records:
                        val = record.get_value()
                        if val: devices.add(val)
                client.close()
                print(f"🌍 [Device List] Found {len(devices)} remote devices.")
            except Exception as remote_e:
                print(f"⚠️ [Device List] 远程库查询失败 (非致命): {remote_e}")
    except Exception as e:
        print(f"⚠️ [Device List] 远程连接初始化错误: {e}")

    # --- 步骤 B: 合并本地模拟设备 (关键修复) ---
    # 即使远程查不到，这里也能保证显示你正在运行的 Python 模拟器
    try:
        local_count = 0
        for device_key, device_info in GLOBAL_STATE['devices'].items():
            # device_key 格式通常是 "IP_TYPE" 或直接是 IP
            # 我们优先提取 device_info 里的 'ip'，如果没有则解析 key
            ip = device_info.get('ip')
            if not ip:
                ip = device_key.split('_')[0] # 尝试从 key 提取 IP
            
            if ip:
                devices.add(ip)
                local_count += 1
        print(f"💻 [Device List] Added {local_count} local simulation devices.")
    except Exception as local_e:
        print(f"❌ [Device List] 本地合并错误: {local_e}")

    # --- 步骤 C: 格式化返回 ---
    final_list = list(devices)
    final_list.sort()
    
    # 如果列表为空，返回一个友好的错误提示，而不是空列表，方便前端调试
    if not final_list:
        print("⚠️ [Device List] No devices found in either Remote DB or Local Memory.")
    
    return jsonify(final_list)

```

### 修改点解析（为什么这样做更好？）

1. **双保险机制**：
* 以前的代码：只查远程 -> 远程连不上或没数据 -> **界面空白**。
* 现在的代码：先查远程，再查本地 `GLOBAL_STATE`。只要你运行了 `device_tension.py`，界面上就一定会有 `127.0.0.1`，演示绝对稳。


2. **容错处理**：
* 我在远程查询部分加了独立的 `try-except`。这意味着，即使 `MONITOR_URL` 配置错了、Token 过期了或者网络断了，**也不会卡死接口**。代码会继续执行“步骤 B”，把本地设备显示出来。


3. **Tag 名称的潜在问题**：
* 代码里依然保留了 `tag: "device"`。如果你发现远程设备（如 `energy*1*1`）还是没出来，很有可能远程数据库里的 Tag 名字不叫 `"device"`（可能叫 `"device_id"` 或 `"sn"`）。但至少现在你能看到模拟设备了。



### 操作步骤

1. **替换**：将上述代码替换到 `backend_server_influx.py` 的第 238 行左右。
2. **重启**：重启 Flask 后端。
3. **运行**：确保 `device_sender_oil.py` 或 `device_tension.py` 正在运行。
4. **刷新**：去前端点击“刷新列表”，你应该能立刻看到模拟设备的 IP。